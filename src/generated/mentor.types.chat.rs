// This file is @generated by prost-build.
/// Поток Чата (Диалог).
/// Один бот может иметь несколько диалогов с одним пользователем.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ChatThread {
    /// Уникальный ID Чата.
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// ID бота, с которым идет диалог.
    #[prost(uint32, tag = "2")]
    pub bot_id: u32,
    /// ID пользователя (дистрибьютора), владеющего чатом.
    #[prost(uint32, tag = "3")]
    pub distributor_id: u32,
    /// Название чата (редактируемое пользователем).
    #[prost(string, tag = "4")]
    pub title: ::prost::alloc::string::String,
    /// Настройки чата (режим ответа и т.д.).
    #[prost(message, optional, tag = "5")]
    pub configuration: ::core::option::Option<chat_thread::Configuration>,
    /// Последнее сообщение (для превью в списке).
    #[prost(message, optional, tag = "6")]
    pub last_message: ::core::option::Option<Message>,
}
/// Nested message and enum types in `ChatThread`.
pub mod chat_thread {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(uint32, tag = "1")]
        pub id: u32,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::ChatThread>,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Configuration {
        #[prost(enumeration = "configuration::chat_mode::Id", tag = "1")]
        pub response_mode: i32,
        /// Режим "Думать дольше" (Sinking Mode) для более качественных ответов.
        #[prost(bool, tag = "2")]
        pub sinking_mode_enabled: bool,
    }
    /// Nested message and enum types in `Configuration`.
    pub mod configuration {
        /// Режим ответа бота в чате.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct ChatMode {}
        /// Nested message and enum types in `ChatMode`.
        pub mod chat_mode {
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum Id {
                /// Не указан
                Unspecified = 0,
                /// Отвечать текстом (по умолчанию)
                Text = 1,
                /// Отвечать голосом (Voice)
                Voice = 2,
            }
            impl Id {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        Self::Unspecified => "UNSPECIFIED",
                        Self::Text => "TEXT",
                        Self::Voice => "VOICE",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "UNSPECIFIED" => Some(Self::Unspecified),
                        "TEXT" => Some(Self::Text),
                        "VOICE" => Some(Self::Voice),
                        _ => None,
                    }
                }
            }
        }
    }
}
/// Сообщение в чате.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Message {
    /// Уникальный ID Сообщения.
    #[prost(uint64, tag = "1")]
    pub id: u64,
    /// ID чата, к которому относится сообщение.
    #[prost(uint32, tag = "2")]
    pub thread_id: u32,
    /// Кто отправил сообщение.
    #[prost(enumeration = "message::role::Id", tag = "3")]
    pub role: i32,
    /// Содержимое.
    #[prost(message, optional, tag = "4")]
    pub content: ::core::option::Option<message::Content>,
    /// Добавлено ли сообщение в избранное.
    #[prost(bool, tag = "5")]
    pub is_favorite: bool,
    /// Время создания.
    #[prost(message, optional, tag = "6")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Message`.
pub mod message {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(uint64, tag = "1")]
        pub id: u64,
    }
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Message>,
    }
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Role {}
    /// Nested message and enum types in `Role`.
    pub mod role {
        /// Роль автора сообщения.
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Id {
            /// Не указана
            Unspecified = 0,
            /// Пользователь
            User = 1,
            /// Бот (Ассистент)
            Bot = 2,
            /// Система (уведомления)
            System = 3,
        }
        impl Id {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::User => "USER",
                    Self::Bot => "BOT",
                    Self::System => "SYSTEM",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "USER" => Some(Self::User),
                    "BOT" => Some(Self::Bot),
                    "SYSTEM" => Some(Self::System),
                    _ => None,
                }
            }
        }
    }
    /// Основной контент сообщения.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Content {
        #[prost(oneof = "content::Kind", tags = "1, 2")]
        pub kind: ::core::option::Option<content::Kind>,
    }
    /// Nested message and enum types in `Content`.
    pub mod content {
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct AudioContent {
            /// Ссылка на аудиофайл (CDN / S3).
            #[prost(string, tag = "1")]
            pub url: ::prost::alloc::string::String,
            /// Текст расшифровки (Speech-to-Text).
            #[prost(string, tag = "2")]
            pub transcription: ::prost::alloc::string::String,
            /// Длительность аудио в секундах.
            #[prost(int32, tag = "3")]
            pub duration_seconds: i32,
            /// MIME type, например "audio/ogg".
            #[prost(string, tag = "4")]
            pub mime_type: ::prost::alloc::string::String,
        }
        #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Kind {
            /// Простой текст / Markdown.
            #[prost(string, tag = "1")]
            Text(::prost::alloc::string::String),
            /// Голосовое сообщение / Аудио.
            #[prost(message, tag = "2")]
            Audio(AudioContent),
        }
    }
}
/// Событие в реальном времени (Server -> Client Stream).
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct ChatEvent {
    #[prost(oneof = "chat_event::Event", tags = "1, 2, 3")]
    pub event: ::core::option::Option<chat_event::Event>,
}
/// Nested message and enum types in `ChatEvent`.
pub mod chat_event {
    /// Индикатор активности бота.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct TypingIndicator {
        #[prost(enumeration = "typing_indicator::Activity", tag = "1")]
        pub activity: i32,
    }
    /// Nested message and enum types in `TypingIndicator`.
    pub mod typing_indicator {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Activity {
            Unspecified = 0,
            /// Печатает сообщение...
            Typing = 1,
            /// Записывает голосовое...
            RecordingVoice = 2,
        }
        impl Activity {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Typing => "TYPING",
                    Self::RecordingVoice => "RECORDING_VOICE",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "TYPING" => Some(Self::Typing),
                    "RECORDING_VOICE" => Some(Self::RecordingVoice),
                    _ => None,
                }
            }
        }
    }
    /// Ошибка в стриме.
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Error {
        #[prost(string, tag = "1")]
        pub code: ::prost::alloc::string::String,
        #[prost(string, tag = "2")]
        pub message: ::prost::alloc::string::String,
    }
    #[derive(Clone, PartialEq, Eq, Hash, ::prost::Oneof)]
    pub enum Event {
        /// Индикатор набора текста/записи голоса.
        #[prost(message, tag = "1")]
        Typing(TypingIndicator),
        /// Новое пришедшее сообщение.
        #[prost(message, tag = "2")]
        NewMessage(super::Message),
        /// Ошибка стрима или обработки.
        #[prost(message, tag = "3")]
        Error(Error),
    }
}

// This file is @generated by prost-build.
/// Pricing Plan (Subscription Plan)
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PricingPlan {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Creator User ID or Company ID (u32, assuming users are u32? Wait, User ID is UUID string)
    /// The spec says "creatorId (u32)". Let's stick to u32 for now, maybe creator is a different entity ID space?
    /// Actually, User ID in identity.proto is string UUID. But PricingPlan spec says u32.
    /// I will use string to be safe if it refers to User.
    #[prost(string, tag = "2")]
    pub creator_id: ::prost::alloc::string::String,
    #[prost(enumeration = "PricingPlanStatus", tag = "3")]
    pub status: i32,
    #[prost(enumeration = "PricingPlanType", tag = "4")]
    pub r#type: i32,
    /// Price configuration
    ///
    /// "10.00"
    #[prost(string, tag = "5")]
    pub price: ::prost::alloc::string::String,
    #[prost(uint32, tag = "6")]
    pub currency_id: u32,
    /// Duration in months
    #[prost(uint32, tag = "7")]
    pub duration_months: u32,
    /// Feature flags / constraints
    #[prost(map = "string, string", tag = "8")]
    pub features: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ::prost::alloc::string::String,
    >,
    /// Quota Rules included in this plan
    #[prost(message, repeated, tag = "9")]
    pub quota_rules: ::prost::alloc::vec::Vec<QuotaRule>,
    #[prost(message, optional, tag = "10")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "11")]
    pub updated_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Rule for calculating quota limits
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QuotaRule {
    #[prost(uint32, tag = "1")]
    pub id: u32,
    #[prost(uint32, tag = "2")]
    pub plan_id: u32,
    /// Quota Template Parameters
    #[prost(message, optional, tag = "3")]
    pub quota_template: ::core::option::Option<QuotaTemplate>,
    /// List of Bot IDs included in this quota group
    #[prost(uint32, repeated, tag = "4")]
    pub included_bot_ids: ::prost::alloc::vec::Vec<u32>,
}
/// Quota Template Configuration
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct QuotaTemplate {
    /// e.g. "MESSAGE", "CALL_MINUTES"
    #[prost(string, tag = "1")]
    pub resource_type: ::prost::alloc::string::String,
    /// Limit per cycle (e.g. 50)
    #[prost(int32, tag = "2")]
    pub limit_per_cycle: i32,
    /// Cycle duration (e.g. "1d", "1m")
    #[prost(string, tag = "3")]
    pub cycle_duration_iso: ::prost::alloc::string::String,
    /// Rollover limit (cumulative)
    #[prost(int32, tag = "4")]
    pub rollover_limit: i32,
}
/// User Subscription
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Subscription {
    /// UUID
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// UUID
    #[prost(string, tag = "2")]
    pub user_id: ::prost::alloc::string::String,
    /// Plan details snapshot or reference
    #[prost(uint32, tag = "3")]
    pub plan_id: u32,
    /// Optional full details
    #[prost(message, optional, tag = "4")]
    pub plan_snapshot: ::core::option::Option<PricingPlan>,
    #[prost(enumeration = "SubscriptionStatus", tag = "5")]
    pub status: i32,
    #[prost(enumeration = "PaymentType", tag = "6")]
    pub payment_type: i32,
    #[prost(message, optional, tag = "7")]
    pub starts_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(message, optional, tag = "8")]
    pub expires_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(bool, tag = "9")]
    pub auto_renew: bool,
    /// Total contract price
    #[prost(string, tag = "10")]
    pub total_price: ::prost::alloc::string::String,
}
/// Dashboard Data
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscriptionDashboardData {
    /// "150.00"
    #[prost(string, tag = "1")]
    pub total_monthly_payment: ::prost::alloc::string::String,
    #[prost(int32, tag = "2")]
    pub call_balance_seconds: i32,
    #[prost(message, repeated, tag = "3")]
    pub subscriptions: ::prost::alloc::vec::Vec<Subscription>,
}
/// Transaction History Item
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Transaction {
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub user_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    /// "-10.00"
    #[prost(string, tag = "4")]
    pub amount: ::prost::alloc::string::String,
    #[prost(uint32, tag = "5")]
    pub currency_id: u32,
    #[prost(enumeration = "transaction::Status", tag = "6")]
    pub status: i32,
    #[prost(message, optional, tag = "7")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
    #[prost(string, tag = "8")]
    pub invoice_id: ::prost::alloc::string::String,
}
/// Nested message and enum types in `Transaction`.
pub mod transaction {
    #[derive(
        Clone,
        Copy,
        Debug,
        PartialEq,
        Eq,
        Hash,
        PartialOrd,
        Ord,
        ::prost::Enumeration
    )]
    #[repr(i32)]
    pub enum Status {
        Unspecified = 0,
        Pending = 1,
        Success = 2,
        Failed = 3,
    }
    impl Status {
        /// String value of the enum field names used in the ProtoBuf definition.
        ///
        /// The values are not transformed in any way and thus are considered stable
        /// (if the ProtoBuf definition does not change) and safe for programmatic use.
        pub fn as_str_name(&self) -> &'static str {
            match self {
                Self::Unspecified => "STATUS_UNSPECIFIED",
                Self::Pending => "STATUS_PENDING",
                Self::Success => "STATUS_SUCCESS",
                Self::Failed => "STATUS_FAILED",
            }
        }
        /// Creates an enum from field names used in the ProtoBuf definition.
        pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
            match value {
                "STATUS_UNSPECIFIED" => Some(Self::Unspecified),
                "STATUS_PENDING" => Some(Self::Pending),
                "STATUS_SUCCESS" => Some(Self::Success),
                "STATUS_FAILED" => Some(Self::Failed),
                _ => None,
            }
        }
    }
}
/// Plan Status
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PricingPlanStatus {
    Unspecified = 0,
    Draft = 1,
    Active = 2,
    Archived = 3,
}
impl PricingPlanStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PRICING_PLAN_STATUS_UNSPECIFIED",
            Self::Draft => "PRICING_PLAN_STATUS_DRAFT",
            Self::Active => "PRICING_PLAN_STATUS_ACTIVE",
            Self::Archived => "PRICING_PLAN_STATUS_ARCHIVED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PRICING_PLAN_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "PRICING_PLAN_STATUS_DRAFT" => Some(Self::Draft),
            "PRICING_PLAN_STATUS_ACTIVE" => Some(Self::Active),
            "PRICING_PLAN_STATUS_ARCHIVED" => Some(Self::Archived),
            _ => None,
        }
    }
}
/// Plan Type
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PricingPlanType {
    Unspecified = 0,
    /// Default content subscription
    Subscription = 1,
    /// Paid access to create bots
    CreatorAccess = 2,
}
impl PricingPlanType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PRICING_PLAN_TYPE_UNSPECIFIED",
            Self::Subscription => "PRICING_PLAN_TYPE_SUBSCRIPTION",
            Self::CreatorAccess => "PRICING_PLAN_TYPE_CREATOR_ACCESS",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PRICING_PLAN_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "PRICING_PLAN_TYPE_SUBSCRIPTION" => Some(Self::Subscription),
            "PRICING_PLAN_TYPE_CREATOR_ACCESS" => Some(Self::CreatorAccess),
            _ => None,
        }
    }
}
/// Subscription Status
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SubscriptionStatus {
    Unspecified = 0,
    Active = 1,
    Cancelled = 2,
    Expired = 3,
    /// Payment failed
    Suspended = 4,
}
impl SubscriptionStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "SUBSCRIPTION_STATUS_UNSPECIFIED",
            Self::Active => "SUBSCRIPTION_STATUS_ACTIVE",
            Self::Cancelled => "SUBSCRIPTION_STATUS_CANCELLED",
            Self::Expired => "SUBSCRIPTION_STATUS_EXPIRED",
            Self::Suspended => "SUBSCRIPTION_STATUS_SUSPENDED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SUBSCRIPTION_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "SUBSCRIPTION_STATUS_ACTIVE" => Some(Self::Active),
            "SUBSCRIPTION_STATUS_CANCELLED" => Some(Self::Cancelled),
            "SUBSCRIPTION_STATUS_EXPIRED" => Some(Self::Expired),
            "SUBSCRIPTION_STATUS_SUSPENDED" => Some(Self::Suspended),
            _ => None,
        }
    }
}
/// Payment Type
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum PaymentType {
    Unspecified = 0,
    /// One-time payment
    Prepaid = 1,
    /// Monthly subscription
    Recurring = 2,
}
impl PaymentType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PAYMENT_TYPE_UNSPECIFIED",
            Self::Prepaid => "PAYMENT_TYPE_PREPAID",
            Self::Recurring => "PAYMENT_TYPE_RECURRING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PAYMENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "PAYMENT_TYPE_PREPAID" => Some(Self::Prepaid),
            "PAYMENT_TYPE_RECURRING" => Some(Self::Recurring),
            _ => None,
        }
    }
}

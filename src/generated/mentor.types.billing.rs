// This file is @generated by prost-build.
/// Тарифный план бота (публичная модель для отображения в каталоге).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BotTariffPlan {
    /// Уникальный идентификатор тарифного плана.
    #[prost(uint32, tag = "1")]
    pub plan_id: u32,
    /// Идентификатор создателя (дистрибьютора), создавшего план.
    #[prost(uint32, tag = "2")]
    pub creator_id: u32,
    /// Статус тарифного плана.
    #[prost(enumeration = "bot_tariff_plan::status::Id", tag = "3")]
    pub status: i32,
    /// Карта распределения ботов по группам квот.
    /// Ключ: ID бота (uint32).
    /// Значение: ID квоты (uint32), к которой бот привязан.
    /// Это позволяет понять, какие боты делят между собой общие ресурсы.
    #[prost(map = "uint32, uint32", tag = "4")]
    pub bot_quota: ::std::collections::HashMap<u32, u32>,
    /// Описание самих квот.
    /// Ключ: ID квоты (uint32), на который ссылается bot_quota.
    /// Значение: Метрики (лимиты) этой квоты.
    #[prost(map = "uint32, message", tag = "5")]
    pub day_quota_metrics: ::std::collections::HashMap<
        u32,
        bot_tariff_plan::QuotaMetrics,
    >,
    /// Стоимость подписки за один месяц (в базовой валюте).
    #[prost(message, optional, tag = "6")]
    pub month_price: ::core::option::Option<super::Money>,
    /// Общая длительность подписки в месяцах (срок действия контракта).
    #[prost(uint32, tag = "7")]
    pub duration_months: u32,
}
/// Nested message and enum types in `BotTariffPlan`.
pub mod bot_tariff_plan {
    /// Идентификатор плана.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(uint32, tag = "1")]
        pub plan_id: u32,
    }
    /// Список тарифных планов.
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::BotTariffPlan>,
    }
    /// Статус тарифного плана.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Status {}
    /// Nested message and enum types in `Status`.
    pub mod status {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Id {
            /// Не указан
            Unspecified = 0,
            /// Черновик (виден только автору)
            Draft = 1,
            /// Активен (виден всем)
            Active = 2,
            /// В архиве (доступен только старым подписчикам)
            Archived = 3,
        }
        impl Id {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Draft => "DRAFT",
                    Self::Active => "ACTIVE",
                    Self::Archived => "ARCHIVED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "DRAFT" => Some(Self::Draft),
                    "ACTIVE" => Some(Self::Active),
                    "ARCHIVED" => Some(Self::Archived),
                    _ => None,
                }
            }
        }
    }
    /// Метрики квоты (лимиты ресурсов).
    /// Используется для описания того, что включает в себя конкретная группа квот.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct QuotaMetrics {
        /// Количество текстовых сообщений.
        #[prost(uint32, tag = "1")]
        pub msg: u32,
        /// Количество секунд звонков.
        #[prost(uint32, tag = "2")]
        pub call: u32,
    }
}
/// Подписка на бота (экземпляр плана).
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BotSubscription {
    /// Внутренний уникальный ID подписки в системе.
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// Порядковый номер подписки у дистрибьютора на данного создателя (для чеков/счетов).
    #[prost(uint32, tag = "2")]
    pub nonce: u32,
    /// Идентификатор создателя контента (на кого подписались).
    #[prost(uint32, tag = "3")]
    pub creator_id: u32,
    /// Идентификатор дистрибьютора, через которого прошла продажа (реферальная система).
    #[prost(uint32, tag = "4")]
    pub distributor_id: u32,
    /// Ссылка на тарифный план, по которому приобретена подписка.
    #[prost(uint32, tag = "5")]
    pub plan_id: u32,
    #[prost(enumeration = "bot_subscription::status::Id", tag = "6")]
    pub status: i32,
    /// Состояние расхода квот.
    /// Ключ: ID квоты (uint32) из BotTariffPlan.quota_metrics.
    /// Значение: Текущий прогресс использования и сроки периода.
    #[prost(map = "uint32, message", tag = "7")]
    pub period_quota_metrics_used: ::std::collections::HashMap<
        u32,
        bot_subscription::PeriodQuotaMetricsUsed,
    >,
    /// Временные метки времени жизни всей подписки.
    ///
    /// Общий срок действия подписки.
    #[prost(message, optional, tag = "8")]
    pub total_period: ::core::option::Option<super::DateRange>,
    /// Дата следующего автоматического приобретения/продления (если контракт предполагает это).
    /// Может отсутствовать, если это конец срока или автопродление невозможно.
    #[prost(message, optional, tag = "9")]
    pub next_renewal_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `BotSubscription`.
pub mod bot_subscription {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        /// Внутренний уникальный ID подписки в системе.
        #[prost(uint32, tag = "1")]
        pub id: u32,
    }
    /// Статус подписки.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Status {}
    /// Nested message and enum types in `Status`.
    pub mod status {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Id {
            /// Не указан
            Unspecified = 0,
            /// Активна
            Active = 1,
            /// Отменена (действует до конца периода)
            Cancelled = 2,
            /// Истекла
            Expired = 3,
            /// Приостановлена (ошибка оплаты)
            Suspended = 4,
        }
        impl Id {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Active => "ACTIVE",
                    Self::Cancelled => "CANCELLED",
                    Self::Expired => "EXPIRED",
                    Self::Suspended => "SUSPENDED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "ACTIVE" => Some(Self::Active),
                    "CANCELLED" => Some(Self::Cancelled),
                    "EXPIRED" => Some(Self::Expired),
                    "SUSPENDED" => Some(Self::Suspended),
                    _ => None,
                }
            }
        }
    }
    /// Использованные ресурсы за текущий период (Usage tracking).
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct PeriodQuotaMetricsUsed {
        /// Сколько уже потрачено ресурсов.
        #[prost(message, optional, tag = "1")]
        pub metrics: ::core::option::Option<super::bot_tariff_plan::QuotaMetrics>,
        /// Период действия квоты.
        #[prost(message, optional, tag = "2")]
        pub period: ::core::option::Option<super::super::DateRange>,
    }
}
/// Данные для дашборда подписок клиента.
/// Агрегирует всю информацию о текущих подписках пользователя для отображения одним запросом.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscriptionDashboardData {
    /// Список профилей создателей (авторов), на которых есть активные или архивные подписки.
    /// Используется для отображения аватарок и имен в списке подписок.
    #[prost(message, repeated, tag = "1")]
    pub creators: ::prost::alloc::vec::Vec<super::identity::PublicUserProfile>,
    /// Список актуальных тарифных планов, связанных с подписками.
    /// Необходим для отображения названий тарифов, лимитов и условий.
    #[prost(message, repeated, tag = "2")]
    pub bot_tariff_plans: ::prost::alloc::vec::Vec<BotTariffPlan>,
    /// Список самих подписок пользователя.
    #[prost(message, repeated, tag = "3")]
    pub bot_subscriptions: ::prost::alloc::vec::Vec<BotSubscription>,
    /// Список самих ботов, на которых есть подписки.
    #[prost(message, repeated, tag = "4")]
    pub bots: ::prost::alloc::vec::Vec<super::bot::Bot>,
}
/// Финансовая транзакция.
#[derive(Clone, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Transaction {
    /// Глобальный уникальный ID транзакции.
    #[prost(uint32, tag = "1")]
    pub id: u32,
    /// ID пользователя (дистрибьютора), который совершил платеж.
    #[prost(uint32, tag = "2")]
    pub distributor_id: u32,
    /// Текущий статус транзакции (Pending, Completed, Failed).
    #[prost(enumeration = "transaction::status::Id", tag = "3")]
    pub status: i32,
    /// Метаданные транзакции (что именно куплено).
    #[prost(message, optional, tag = "4")]
    pub metadata: ::core::option::Option<transaction::Metadata>,
    /// Сумма подписки в базовой валюте (обычно USD для отображения).
    /// Используется для статистики и отчетности.
    #[prost(message, optional, tag = "5")]
    pub amount_base: ::core::option::Option<super::Money>,
    /// Сумма, фактически списанная в валюте оплаты (например, TON, USDT).
    /// Точная сумма транзакции в блокчейне или платежной системе.
    #[prost(message, optional, tag = "6")]
    pub amount_charged: ::core::option::Option<super::Money>,
    /// Дата создания транзакции (UTC).
    #[prost(message, optional, tag = "7")]
    pub created_at: ::core::option::Option<::prost_types::Timestamp>,
}
/// Nested message and enum types in `Transaction`.
pub mod transaction {
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Id {
        #[prost(uint32, tag = "1")]
        pub id: u32,
    }
    /// Список транзакций (для возврата в API).
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct List {
        #[prost(message, repeated, tag = "1")]
        pub items: ::prost::alloc::vec::Vec<super::Transaction>,
    }
    /// Статус транзакции.
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Status {}
    /// Nested message and enum types in `Status`.
    pub mod status {
        #[derive(
            Clone,
            Copy,
            Debug,
            PartialEq,
            Eq,
            Hash,
            PartialOrd,
            Ord,
            ::prost::Enumeration
        )]
        #[repr(i32)]
        pub enum Id {
            /// Не указан
            Unspecified = 0,
            /// В ожидании
            Pending = 1,
            /// Завершена успешно
            Completed = 2,
            /// Ошибка
            Failed = 3,
        }
        impl Id {
            /// String value of the enum field names used in the ProtoBuf definition.
            ///
            /// The values are not transformed in any way and thus are considered stable
            /// (if the ProtoBuf definition does not change) and safe for programmatic use.
            pub fn as_str_name(&self) -> &'static str {
                match self {
                    Self::Unspecified => "UNSPECIFIED",
                    Self::Pending => "PENDING",
                    Self::Completed => "COMPLETED",
                    Self::Failed => "FAILED",
                }
            }
            /// Creates an enum from field names used in the ProtoBuf definition.
            pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                match value {
                    "UNSPECIFIED" => Some(Self::Unspecified),
                    "PENDING" => Some(Self::Pending),
                    "COMPLETED" => Some(Self::Completed),
                    "FAILED" => Some(Self::Failed),
                    _ => None,
                }
            }
        }
    }
    /// Метаданные транзакции (детали продукта/услуги).
    #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
    pub struct Metadata {
        /// Детали транзакции (в зависимости от типа продукта).
        /// Позволяет добавлять новые типы покупок без изменения основной структуры Transaction.
        #[prost(oneof = "metadata::Details", tags = "1")]
        pub details: ::core::option::Option<metadata::Details>,
    }
    /// Nested message and enum types in `Metadata`.
    pub mod metadata {
        /// Детали транзакции для подписки на бота.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
        pub struct BotSubscriptionDetails {
            /// ID приобретенной/продленной подписки.
            #[prost(uint32, tag = "1")]
            pub bot_subscription_id: u32,
            /// Период, за который была оплата подписки (например, 01.01.2025 - 01.02.2025).
            #[prost(message, optional, tag = "2")]
            pub subscription_period: ::core::option::Option<
                super::super::super::DateRange,
            >,
        }
        /// Детали транзакции (в зависимости от типа продукта).
        /// Позволяет добавлять новые типы покупок без изменения основной структуры Transaction.
        #[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Oneof)]
        pub enum Details {
            /// Покупка подписки на бота.
            #[prost(message, tag = "1")]
            BotSubscription(BotSubscriptionDetails),
        }
    }
}
